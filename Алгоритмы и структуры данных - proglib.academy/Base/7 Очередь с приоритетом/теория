Очередь с приоритетом - АТД (интерфейс), поддерживающий три операции:
    push - добавить в очередь элемент с назначенным приоритетом (insert, insertWithPriority)
    top - просмотреть элемент с наивысшим приоритетом без извлечения (peek, peekAtNext)
    pop - извлечь из очереди и (опционально) вернуть элемент с наивысшим приоритетом (get, getNext, popElement, getMaximum)

Двоичная куча, пирамида или сортирующее дерево - такое почти полное дерево, для которого выполнены три условия. Реализует интерфейс очереди с приоритетом
    1. значение в любой вершине не меньше, чем значения её потомков
    2. глубина листьев (расстояние до корня) отличается не более чем на один (если справа глубна 1, то слева не может быть глубины 2 и больше из-за правила 3)
    3. последний слой заполняется слева направо

    Глубина кучи        
        количество элементов в k слое - 2^k (при условии полной заполненности)
            в 0 слое - 1
            в 1 слое - 2
            в 2 слое - 4
        Всего элементов в k слоях - 1 + 2 + 4 + ... + (2^k) = (2^(k+1)) - 1
        Глубина кучи = O(log n), где n - количество элементов

    Способ хранения
        удобный способ хранения для двоичной кучи - массив
        - последовательно храним все элементы кучи "по слоям"
        - корень - первый элемент массива, второй и третий элемент - дочерние элементы и так далее

        16 11 9 10 5 6 8 1 2 4
    
    Индексация
        такой способ хранения элементов в массиве позволяет быстро получать дочерние и родительские элементы.
        считаем, что индексация элементов массива начинается с 0. A[0] - элемент в корне
        - потомки элемента A[i] - элементы A[2i + 1] и A[2i + 2]
        - предок элемента A[i] - элемент A[(i-1)/2]

    Восстановление кучи (если изменяется один из элементов, то она может перестать удовлетворять св-ву порядочности)
        SiftDown / Heapify (O(log n)) - элемент стал меньше, чем дочерний и его нужно "просеять" вниз
            - сравниваем i-ый элемент с сыновьями
            - если i-ый элемент меньше одного из сыновей
            - меняем его с наибольшим сыном
            - спускаемся на место поднятого сына
            - повторять до тех пор, пока не спустимся к элементу, который не меньше сыновей (или их нет)
            - больше ничего делать не надо, т.к. дерево уже куча
        SiftUp (O(log n)) - лемент стал больше, чем родительский и его нужно "просеять" наверх
            - в конце работы алгоритма "испорченный" элемент поднимается на мето,
            выше которого элементы не меньше, либо становится на место корня
    
    Добавление элемента
        - добавить элемент в конец кучи
        - восстановить св-во упорядочности, с помощью SiftUp
        - время работы (O(log n)) - если буффер для кучи позволяет добавить элемент без выделения памяти

    Извлечение максимума
        - максимальный элемент рапологается в корне
        - алгоритм:
            - сохранить значение корневого элемента для возврата
            - скопировать последний элемент в корень, удаляем плоследний элемент 
            - вызвать SiftDown для корня
            - возвратить созраненны корневой элемент
        - время работы (O(log n))

Задача. Построение кучи. Создать кучу из неупорядоченного массива водных данных.
    - если выполнить SiftDown для всех элементов массива A, начиная с последего и кончая первым, он станет кучей
    - достаточно вызвать SiftDown для всех элементов массива А с (n/2 - 1)-го по 0-ой
        -  SiftDown(А, i) не сделает ничего для листьев. Листья имеют индекс i >= n/2
    
    Асимптоматика построения. 
        время работы BuildHeap T(n) = O(n)

Последняя задача из лекции это 1.7.2 (про тупики)
    - можно записывать в очередь с приоритетом время ОТПРАВЛЕНИЯ
    - удалять все времена отправления, которое < время нового прибытия
    - каждый раз смотреть count элементов в куче